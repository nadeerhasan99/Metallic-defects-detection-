clc; clear; close all;

% Set the path to the directories with correct file separators
groundTruthDir = fullfile('metalic', 'Ground truth - png');
sourceDir = fullfile('metalic', 'Source Images - bmp');

% Set the file extension
fileExtSource = '.bmp';
fileExtGround = '.png';

% Set the number of images (N)
N = 600; % Update N to the actual number of images you have

% Initialize arrays to store IoU values and corresponding image indices
iouValues = zeros(N, 1);
maxIoUIndex = 0;
minIoUIndex = 0;

% Loop through the images and display them side by side
for i = 1:N
    % Construct the file names using fullfile
    if i <= 300
        groundTruthFile = fullfile(groundTruthDir, ['In_' num2str(i) fileExtGround]);
        sourceFile = fullfile(sourceDir, ['In_' num2str(i) fileExtSource]);
    else
        groundTruthFile = fullfile(groundTruthDir, ['Sc_' num2str(i-300) fileExtGround]);
        sourceFile = fullfile(sourceDir, ['Sc_' num2str(i-300) fileExtSource]);
    end

    % Read the images if the files exist
    if exist(groundTruthFile, 'file') && exist(sourceFile, 'file')
        groundTruthImage = imread(groundTruthFile);
        sourceImage = imread(sourceFile);

        processedImage = preProcess(sourceImage);
        
        [segmentedImage, ~] = segmentImage(processedImage);
        
        % Calculate IoU for the current image
        intersectionOverUnion = calculateIoU(groundTruthImage, segmentedImage);
        
        % Store the IoU value in the array
        iouValues(i) = intersectionOverUnion;
        
        % Update max and min IoU indices
        if i == 1 || intersectionOverUnion > iouValues(maxIoUIndex)
            maxIoUIndex = i;
        end
        
        if i == 1 || intersectionOverUnion < iouValues(minIoUIndex)
            minIoUIndex = i;
        end
    else
        disp(['One or both of the files do not exist for image ' num2str(i)]);
    end
end

% Calculate the average IoU over all images
averageIoU = mean(iouValues);

% Display the results
disp(['Average IoU over ' num2str(N) ' images: ' num2str(averageIoU*100) '%']);
disp(['Image index with maximum IoU: ' num2str(maxIoUIndex) ' (IoU: ' num2str(iouValues(maxIoUIndex)) ')']);
%%
function processedImage = preProcess(sourceImage, seRadius, neighborhoodSize, sigma)
    % Set default values if not provided
    if nargin < 2
        seRadius = 200;
    end

    if nargin < 3
        neighborhoodSize = [3, 3];
    end

    if nargin < 4
        sigma = 1;
    end

    % Convert the input image to grayscale if it's a color image
    if size(sourceImage, 3) == 3
        sourceImage = rgb2gray(sourceImage);
    end

    % Apply top-hat transformation
    topHatTransformed = imtophat(sourceImage, strel('disk', seRadius));
    


    % Apply median filtering
    medianFilteredImage = medfilt2(topHatTransformed, neighborhoodSize); % medianFilteredImage

    % Apply Gaussian filtering
    processedImage = imgaussfilt(medianFilteredImage, sigma);
    
    

end

function intersectionOverUnion = calculateIoU(groundTruth1, groundTruth2)
    % Check if the input images have the same size
    if ~isequal(size(groundTruth1), size(groundTruth2))
        error('Input images must have the same dimensions.');
    end

    % Convert binary images to logical type
    groundTruth1 = logical(groundTruth1);
    groundTruth2 = logical(groundTruth2);

    % Calculate intersection and union
    intersection = sum(groundTruth1(:) & groundTruth2(:));
    union = sum(groundTruth1(:) | groundTruth2(:));

    % Calculate Intersection over Union (IoU)
    intersectionOverUnion = intersection / union;
end

function [BW,maskedImage] = segmentImage(X)
    %segmentImage Segment image using auto-generated code from Image Segmenter app
    %  [BW,MASKEDIMAGE] = segmentImage(X) segments image X using auto-generated
    %  code from the Image Segmenter app. The final segmentation is returned in
    %  BW, and a masked image is returned in MASKEDIMAGE.
    
    % Auto-generated by imageSegmenter app on 30-Nov-2023
    %----------------------------------------------------
    
    
    % Threshold image with adaptive threshold
    BW = imbinarize(im2gray(X), 'adaptive', 'Sensitivity', 0.79, 'ForegroundPolarity', 'bright');
    
    % Close mask with disk
    radius = 2;
    decomposition = 0;
    se = strel('disk', radius, decomposition);
    BW = imclose(BW, se);
    
    % Invert mask
    BW = imcomplement(BW);
    
    
    % Create masked image.
    maskedImage = X;
    maskedImage(~BW) = 0;
end

